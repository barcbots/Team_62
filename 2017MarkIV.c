#pragma config(Sensor, in1,    liftPot,        sensorPotentiometer)
#pragma config(Sensor, in2,    gyro,           sensorGyro)
#pragma config(Sensor, dgtl1,  liftStop,       sensorTouch)
#pragma config(Sensor, dgtl2,  claw,           sensorDigitalOut)
#pragma config(Sensor, dgtl9,  leftEnc,        sensorQuadEncoder)
#pragma config(Sensor, dgtl11, rightEnc,       sensorQuadEncoder)
#pragma config(Motor,  port1,           rightWheel1,   tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           rightWheel2,   tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           leftWheel1,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           leftLift1,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           rightLift1,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           rightLift2,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           rightLift3,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           leftLift2,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           leftLift3,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          leftWheel2,    tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JonLib2/JonLib2.h"

/*///////////////////////////////////////////////////////////
/////____________/\\\\\____/\\\\\\\\\_____              /////
///// ________/\\\\////___/\\\///////\\\___             /////
/////  _____/\\\///_______\///______\//\\\__            /////
/////   ___/\\\\\\\\\\\______________/\\\/___           /////
/////    __/\\\\///////\\\_________/\\\//_____          /////
/////     _\/\\\______\//\\\_____/\\\//________         /////
/////      _\//\\\______/\\\____/\\\/___________        /////
/////       __\///\\\\\\\\\/____/\\\\\\\\\\\\\\\_       /////
/////        ____\/////////_____\///////////////__      /////
///// 2017 Mark V Robot                                 /////
///// Main Code                                         /////
///// Authors: Jonathan Damico (jj_damico@yahoo.com)    /////
///// Since: March 24, 2017                             /////
*////////////////////////////////////////////////////////////

//required by JonLib2
//sets speed of left wheels on robot
void setLeftWheelSpeed (int speed) {
	motor[leftWheel1] = speed;
	motor[leftWheel2] = speed;
}

//required by JonLib2
//sets speed of right wheels on robot
void setRightWheelSpeed (int speed) {
	motor[rightWheel1] = speed;
	motor[rightWheel2] = speed;
}

//required by JonLib2
//takes number of inches for the robot to travel
//returns encoder ticks for left drivebase to reach that distance
int leftEncoderCurve (int target) {
	return 27.882*target*;
}

//required by JonLib2
//takes number of inches for robot to travel
//returns encoder ticks for right drivebase to reach that distance
//90 degrees is a right turn
int rightEncoderCurve (int target) {
	return 23.093*target;
}

//required by JonLib2
//takes degrees for robot to travel
//returns gyro value for degrees
int gyroCurve (int target) {
	return -10.783*target;
}

//sets all lift motors to power
void lift (int power) {
	motor[leftLift1]  = power;
	motor[rightLift1] = power;
	motor[leftLift2]  = power;
	motor[rightLift2] = power;
	motor[leftLift3]  = power;
	motor[rightLift3] = power;
}

//task to test all motors with differient button inputs
task motorPortTest() {
	while(true) {
		motor[port1] 	= vexRT(Btn7U)*127; //rightDrive1 R
		motor[port2] 	= vexRT(Btn7D)*127; //rightDrive2 R
		motor[port3] 	= vexRT(Btn7L)*127; //leftDrive1
		motor[port4] 	= vexRT(Btn7R)*127; //leftLift1
		motor[port5] 	= vexRT(Btn8U)*127; //rightLift1 R
		motor[port6] 	= vexRT(Btn8D)*127; //rightLift2
		motor[port7] 	= vexRT(Btn8L)*127; //rightLift3 R
		motor[port8] 	= vexRT(Btn8R)*127; //leftLift2 R
		motor[port9] 	= vexRT(Btn5U)*127; //leftLift3
		motor[port10]	= vexRT(Btn6U)*127; //leftDrive2
	}
}

void pre_auton() { }

	drivebase db;

	gyroscope g;
void autonomousTest () {
	clearDebugStream();
	resetSensor(leftEnc);
	resetSensor(rightEnc);
	resetSensor(gyro); //.17, .5

	initPIDGyroscope(g, gyro, 0.25, 0.0001, 0.7, 30, -1, 40);
	//addGyroTargetPIDAutoLeftSwingTurn(g, 1000);
	//setWheelSpeed(0);

	initPIDDrivebase(db, leftEnc, rightEnc, gyro, 0.15, 0.0001, 0.7, 30, -1, 20, 0.3);

	//addDrivebaseTargetPIDAuto(db, 15, 20);

	//int targets[5];
	//targets[0] = 48;
	//targets[1] = 0;
	//targets[2] = 12;
	//targets[3] = 36;
	//targets[4] = 0;

	//for(int i = 0; i<5; i++) {
	//	setDrivebaseTargetPIDAuto(db, targets[i]);
	//	delay(200);
	//}
}

#define LIFT_RAISE 2200
#define LIFT_DUMP 3000
#define LIFT_SLOW 2000
#define LIFT_DOWN -1

int liftTarget = 0;
task autoMoveLift () {
	liftTarget = SensorValue[liftPot];
	while(true) {
		if(liftTarget == -1) {
			while(!SensorValue[liftStop]) {
				lift(limit(-127,SensorValue[liftPot]>LIFT_SLOW?127:60));
			}
			liftTarget = SensorValue[liftPot]-250;
		} else {
			lift(limit((liftTarget-SensorValue[liftPot])*0.08,SensorValue[liftPot]>LIFT_SLOW?127:60));
		}
	}
}

void close () {
	SensorValue[claw] = 0;
}

void open () {
	SensorValue[claw] = 1;
}

void setLiftTarget (int target) {
	liftTarget = target;
}

void programmingSkils () {
	startTask(autoMoveLift);

	//init everything, consider moving to pre-auton task so everything is  initialised  before skills starts,  extra second or so
	resetSensor(leftEnc);
	resetSensor(rightEnc);
	resetSensor(gyro);

	clearDebugStream();

	gyroscope g;
	drivebase db;
	initPIDGyroscope(g, gyro, 0.25, 0.0001, 0.7, 30, -1, 40);
	initPIDDrivebase(db, leftEnc, rightEnc, gyro, 0.15, 0.0001, 0.7, 30, -1, 20, 0.5);
	initPIDDrivebase(db, leftEnc, rightEnc, gyro, 0.3, 0.0001, 0.7, 30, -1, 20, 0.0);

	open();

	addDrivebaseTargetPIDAuto(db, 60);
	close();
	delay(500);
	setLiftTarget(LIFT_RAISE);
	setDrivebaseTargetPIDAuto(db, 12);

	addGyroTargetPIDAutoRightSwingTurn(g, -900);
	delay(300);
	addDrivebaseTargetPIDAuto(db,  -47);
	setLiftTarget(LIFT_DUMP);
	setWheelSpeed(-50);
	delay(200);
	open();
	delay(500);
}

task autonomous () {
	//startTask(autoMoveLift);
	//setLiftTarget(LIFT_DOWN);
	autonomousTest();
	//programmingSkils();
}

void usercontrolMain () {
	while(true) {
		tankDrive(vexRT[Ch3], vexRT[Ch2], 15);

		if(vexRT[Btn8U])
			lift(-127);
		else if(vexRT[Btn5U])
			lift(127);
		else if(vexRT[Btn5D] && !SensorValue[liftStop]) {
			if(SensorValue[liftPot]>3100)
				lift(-127);
			else if(SensorValue[liftPot]<LIFT_SLOW)
				lift(-40);
			else
				lift(-80);
		}
		else if(SensorValue[liftStop] && ((abs(vexRT[Ch3])+abs(vexRT[Ch2])>15))//hold down code
			lift(-15);
		else if(SensorValue[liftStop])
			lift(0);
		else if(SensorValue[liftPot]>3100)
			lift(-15);
		else if(SensorValue[liftPot]<2200)
			lift(15);
		else
			lift(0);

		if(vexRT[Btn6U]) {
			SensorValue[claw] = !SensorValue[claw];
			while(vexRT[Btn6U]) { delay(5); }
		}

	}
}

task usercontrol() {
	//startTask(motorPortTest);
	usercontrolMain();
}
